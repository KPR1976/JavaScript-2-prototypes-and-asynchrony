# JavaScript part 2 prototypes and asynchrony

JavaScript, часть 2: прототипы и асинхронность

Для каждого задания выделена отдельная папка. В ней находятся файлы:

--checks.js - файл с базовыми тестами для проверки

--index.js - мое решение

--coursera.js - решение предложенное на курсе

            2) Exercise 2: Коллекция

В этой задаче необходимо реализовать конструктор для создания коллекции элементов.

Заготовка
exercise.zip

Условия
Создание коллекции
Коллекцию можно создать двумя способами: через конструктор Collection или через метод Collection.from().

Через конструктор создается пустая коллекция.

Через метод Collection.from() можно создать коллекцию с начальными значениями, передав в нее массив элементов. Возвращается инстанс конструктора Collection.

Метод values
Метод возвращает массив элементов коллекции.

Метод at
Метод возвращает элемент с определенной позиции (нумерация начинается с единицы, а не нуля). Если позиция не существует, возвращается null.

Метод append
Метод добавляет элемент в коллекцию.

Если в метод append передана другая коллекция, то все её элементы добавляются в текущую.

Метод removeAt
Метод удаляет элемент с переданной позиции (нумерация начинается с единицы) и в случае успеха возвращает true. Если элемента на переданной позиции не существует, то метод возвращает false.

Пояснения
Гарантируется корректное использование методов.
Коллекция может содержать любые элементы кроме экземпляров конструктора Collection.
Ожидается, что все методы (кроме from) будут объявлены в Collection.prototype.
Проверку добавляемого элемента в методе append можно сделать через instanceof.

            3) Exercise3: Параллельное выполнение асинхронных функций
           
В этом задании необходимо реализовать функцию parallel, которая выполняет асинхронные операции параллельно.

Функция parallel принимает два аргумента: массив операций и результирующий callback.

Условия
Операции
Каждая операция – это синхронная или асинхронная функция. На вход ей приходит callback-функция next. По завершению работы операция вызывает функцию next либо с результатом выполнения, либо с ошибкой.

Если операция успешно завершилась, то вызывается callback-функция с первым аргументом null, а вторым – результатом выполнения:

Если операция завершается с ошибкой, то callback-функция вызывается с единственным аргументом – возникшей ошибкой:

Результирующий callback
Результирующий callback (второй параметр функции parallel) вызывается по окончанию выполнения всех операций или при возникновения ошибки в одной из них.

Если все операции завершились успешно, в callback передаётся первым аргументом null, а вторым – массив с результатами выполнения операций. Порядок данных должен соответствовать порядку операций в массиве, а не их вызову.

Если не переданы операции (передан пустой массив), то результатом выполнения должен быть пустой массив.

Если хотя бы одна из операций закончилась ошибкой, то callback-функция вызывается с произошедшей ошибкой. Если несколько операцией завершились ошибкой, то callback будет вызван с первой из них.

Важно. Callback вызывается ровно один раз: либо с первой пойманной ошибкой, либо с результатами выполнения операций.

Ограничения
Гарантируется корректность вызова функции parallel и передача операций в правильном формате.
Гарантируется, что функция next всегда вызывается в операциях.
Пояснения
В данном задании используется термин callback. При этом подходе в асинхронную функцию передается другая функция, которую исходная должна вызвать по завершению. Это способ асинхронной функции сообщить о своем завершении.

По условию задачи мы имеем дело с двумя callback-функциями: 1. Функция next — передается в операцию, которая по своему завершению должна вызвать функцию next. 2. Вторая функция используется внутри операции, чтобы узнать о завершении работы setTimeout.

В данном примере функция setTimeout сама вызывает callback, а для функции operation callback-функцию (next) мы вызываем вручную. Использование функции operation практически не отличается от использования функции setTimeout:

Подсказка
Сохранение порядка можно сделать через замыкания, для каждой операции создавая функцию next:

           
